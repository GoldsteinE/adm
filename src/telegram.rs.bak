use secstr::SecStr;

use crate::runner::Task;

#[derive(Debug, serde::Serialize)]
pub struct SendMessage<'a> {
    pub text: &'a str,
    pub chat_id: isize,
    pub parse_mode: &'static str,
}

pub struct TelegramNotifier {
    http: awc::Client,
    url: SecStr,
    groups: Vec<isize>,
}

impl TelegramNotifier {
    pub fn new(token: SecStr, groups: Vec<isize>) -> Self {
        let http = awc::Client::new();
        let url =
            SecStr::new(format!("https://api.telegram.org/bot{}/sendMessage", token).into_bytes());
        Self { http, url, groups }
    }

    pub async fn notify(
        &self,
        task: &Task,
        success: bool,
    ) -> Result<(), awc::error::SendRequestError> {
        let status = if success { "completed" } else { "failed" };
        let text = &format!(
            r#"
<b>Build {status}!</b>

Repo: <a href="{url}">{owner}/{repo}</a>
Branch: <a href="{url}/tree/{branch}">{branch}</a>
Commit: <a href="{url}/commit/{commit}">{commit}</a>
"#,
            status = status,
            url = task.url,
            repo = task.repo,
            owner = task.owner,
            branch = task.branch,
            commit = task.commit_hash,
        );
        for chat_id in self.groups.iter().copied() {
            let message = SendMessage {
                text,
                chat_id,
                parse_mode: "HTML",
            };
            let resp = self
                .http
                .post(self.url.unsecure())
                .send_json(&message)
                .await?;
            if resp.status().as_u16() >= 400 {
                let error = resp.body().await?;
            }
        }

        Ok(())
    }
}
